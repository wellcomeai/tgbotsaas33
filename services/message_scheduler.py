import asyncio
import logging
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from dataclasses import dataclass

from aiogram import Bot
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ParseMode
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest, TelegramNetworkError

from database import db

logger = logging.getLogger(__name__)


@dataclass
class MessageDetails:
    """–î–µ—Ç–∞–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏"""
    text: str
    media_file_id: Optional[str] = None
    media_type: Optional[str] = None
    keyboard: Optional[List[Dict[str, str]]] = None


class MessageFormatter:
    """Simple message formatter"""
    
    def format_message(self, text: str, user_id: int, first_name: str = None, username: str = None) -> str:
        """Format message with user variables"""
        formatted = text.replace("{user_id}", str(user_id))
        formatted = formatted.replace("{first_name}", first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")
        formatted = formatted.replace("{username}", f"@{username}" if username else first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")
        return formatted


class KeyboardManager:
    """Simple keyboard manager"""
    
    def create_keyboard(self, button_data: List[Dict[str, str]]) -> Optional[InlineKeyboardMarkup]:
        """Create keyboard from button data"""
        if not button_data:
            return None
        
        keyboard = []
        for button in button_data:
            keyboard.append([
                InlineKeyboardButton(
                    text=button.get('text', 'Button'),
                    url=button.get('url', 'https://t.me')
                )
            ])
        
        return InlineKeyboardMarkup(inline_keyboard=keyboard)


class MessageScheduler:
    """–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è Telegram –±–æ—Ç–∞ —Å —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
    
    def __init__(self, bot_manager=None):
        self.bot_manager = bot_manager
        self.formatter = MessageFormatter()
        self.keyboard_manager = KeyboardManager()
        self.running = False
        self.scheduler_task: Optional[asyncio.Task] = None
        self.stats = {
            'messages_processed': 0,
            'messages_sent_success': 0,
            'messages_sent_failed': 0,
            'media_sent_success': 0,
            'text_sent_success': 0,
            'errors': [],
            'last_run': None
        }
    
    async def start(self):
        """Start message scheduler with background task"""
        self.running = True
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
        self.scheduler_task = asyncio.create_task(self._scheduler_loop())
        logger.info("Message scheduler started with background processing")

    async def stop(self):
        """Stop message scheduler"""
        self.running = False
        if self.scheduler_task:
            self.scheduler_task.cancel()
            try:
                await self.scheduler_task
            except asyncio.CancelledError:
                pass
        logger.info("Message scheduler stopped")
    
    async def _scheduler_loop(self):
        """‚úÖ –ù–û–í–û–ï: –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ - —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥"""
        while self.running:
            try:
                logger.info("üîÑ Starting scheduled messages check...")
                stats = await self.process_scheduled_messages()
                self.stats['last_run'] = datetime.now()
                
                if stats['messages_processed'] > 0:
                    logger.info(f"‚úÖ Processed {stats['messages_processed']} messages, "
                              f"sent: {stats['messages_sent_success']}, "
                              f"failed: {stats['messages_sent_failed']}")
                else:
                    logger.debug("üì≠ No messages to process")
                
                # –ñ–¥–µ–º 30 —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
                await asyncio.sleep(30)
                
            except asyncio.CancelledError:
                logger.info("üõë Scheduler loop cancelled")
                break
            except Exception as e:
                logger.error(f"‚ùå Error in scheduler loop: {e}")
                # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º –º–∏–Ω—É—Ç—É –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
                await asyncio.sleep(60)

    def get_scheduler_stats(self) -> Dict[str, Any]:
        """Get scheduler statistics"""
        return {
            'running': self.running,
            'scheduler_task_running': self.scheduler_task is not None and not self.scheduler_task.done(),
            **self.stats
        }
    
    async def process_scheduled_messages(self) -> Dict[str, int]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        logger.debug("üîÑ STARTING SCHEDULED MESSAGES PROCESSING")
        
        # –°–±—Ä–æ—Å —Ç–µ–∫—É—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        current_stats = {
            'messages_processed': 0,
            'messages_sent_success': 0,
            'messages_sent_failed': 0,
            'media_sent_success': 0,
            'text_sent_success': 0,
            'errors': []
        }
        
        try:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –ë–î
            scheduled_messages = await self._get_pending_messages()
            
            if not scheduled_messages:
                logger.debug("üì≠ NO SCHEDULED MESSAGES TO SEND")
                return current_stats
            
            logger.info(f"üì¨ FOUND SCHEDULED MESSAGES: {len(scheduled_messages)}")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            for scheduled_msg in scheduled_messages:
                try:
                    await self._process_single_message(scheduled_msg, current_stats)
                    # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è –ª–∏–º–∏—Ç–æ–≤ Telegram
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"‚ùå ERROR PROCESSING SINGLE MESSAGE {scheduled_msg.id}: {e}")
                    current_stats['messages_sent_failed'] += 1
                    current_stats['errors'].append(f"Message {scheduled_msg.id}: {str(e)}")
                
        except Exception as e:
            logger.error(f"‚ùå ERROR IN SCHEDULED MESSAGES PROCESSING: {e}")
            current_stats['errors'].append(f"Processing error: {str(e)}")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.stats['messages_processed'] += current_stats['messages_processed']
        self.stats['messages_sent_success'] += current_stats['messages_sent_success']
        self.stats['messages_sent_failed'] += current_stats['messages_sent_failed']
        self.stats['media_sent_success'] += current_stats['media_sent_success']
        self.stats['text_sent_success'] += current_stats['text_sent_success']
        self.stats['errors'].extend(current_stats['errors'])
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫ –≤ –ø–∞–º—è—Ç–∏
        if len(self.stats['errors']) > 100:
            self.stats['errors'] = self.stats['errors'][-50:]  # –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 50
        
        logger.debug("‚úÖ SCHEDULED MESSAGES PROCESSING COMPLETED")
        return current_stats
    
    async def _get_pending_messages(self) -> List:
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –≥–æ—Ç–æ–≤—ã—Ö –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑ –ë–î"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º pending —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            pending_messages = await db.get_pending_scheduled_messages(limit=100)
            
            logger.debug(f"üì• Retrieved {len(pending_messages)} pending messages from DB")
            return pending_messages
            
        except Exception as e:
            logger.error(f"‚ùå ERROR GETTING PENDING MESSAGES: {e}")
            return []
    
    async def _process_single_message(self, scheduled_msg, current_stats: dict) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            current_stats['messages_processed'] += 1
            
            logger.info(f"üì§ PROCESSING SCHEDULED MESSAGE id={scheduled_msg.id}, "
                       f"subscriber={scheduled_msg.subscriber_id}, "
                       f"bot={scheduled_msg.bot_id}")
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
            message_details = await self._get_message_details(scheduled_msg)
            
            if not message_details:
                logger.error(f"‚ùå NO MESSAGE DETAILS for message_id={scheduled_msg.message_id}")
                await self._mark_message_failed(scheduled_msg, "No message details")
                current_stats['messages_sent_failed'] += 1
                return
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            success = await self._send_scheduled_message(scheduled_msg, message_details)
            
            if success:
                await self._mark_message_sent(scheduled_msg)
                current_stats['messages_sent_success'] += 1
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                if message_details.media_file_id:
                    current_stats['media_sent_success'] += 1
                else:
                    current_stats['text_sent_success'] += 1
                    
                logger.info(f"‚úÖ MESSAGE SENT SUCCESSFULLY id={scheduled_msg.id}")
            else:
                await self._mark_message_failed(scheduled_msg, "Send failed")
                current_stats['messages_sent_failed'] += 1
                
        except Exception as e:
            logger.error(f"‚ùå ERROR PROCESSING MESSAGE id={scheduled_msg.id}: {e}")
            await self._mark_message_failed(scheduled_msg, str(e))
            current_stats['messages_sent_failed'] += 1
            current_stats['errors'].append(f"Message {scheduled_msg.id}: {str(e)}")
    
    async def _get_message_details(self, scheduled_msg) -> Optional[MessageDetails]:
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –ë–î"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º broadcast message –∏–∑ –ë–î
            broadcast_message = await db.get_broadcast_message_by_id(scheduled_msg.message_id)
            if not broadcast_message:
                logger.error(f"Broadcast message not found: {scheduled_msg.message_id}")
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
            buttons = await db.get_message_buttons(scheduled_msg.message_id)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏
            button_data = []
            for button in buttons:
                button_data.append({
                    'text': button.button_text,
                    'url': button.button_url
                })
            
            return MessageDetails(
                text=broadcast_message.message_text,
                media_file_id=getattr(broadcast_message, 'media_file_id', None),
                media_type=broadcast_message.media_type,
                keyboard=button_data if button_data else None
            )
            
        except Exception as e:
            logger.error(f"‚ùå ERROR GETTING MESSAGE DETAILS for message_id={scheduled_msg.message_id}: {e}")
            return None
    
    async def _send_scheduled_message(self, scheduled_msg, message_details: MessageDetails) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–∞–µ–º –±–æ—Ç–∞ –∏–∑ bot_manager
            if not self.bot_manager or not hasattr(self.bot_manager, 'active_bots'):
                logger.error("‚ùå NO BOT MANAGER OR ACTIVE BOTS")
                return False
            
            # –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –±–æ—Ç–∞
            bot_instance = None
            for bot_id, user_bot in self.bot_manager.active_bots.items():
                if bot_id == scheduled_msg.bot_id:
                    bot_instance = user_bot.bot
                    break
            
            if not bot_instance:
                logger.error(f"‚ùå BOT NOT FOUND for bot_id={scheduled_msg.bot_id}")
                return False
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å—á–∏–∫–µ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            subscriber = await db.get_subscriber_by_bot_and_user(
                scheduled_msg.bot_id, 
                scheduled_msg.subscriber_id
            )
            first_name = getattr(subscriber, 'first_name', None) if subscriber else None
            username = getattr(subscriber, 'username', None) if subscriber else None
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            formatted_text = self.formatter.format_message(
                message_details.text,
                user_id=scheduled_msg.subscriber_id,
                first_name=first_name,
                username=username
            )
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
            reply_markup = None
            if message_details.keyboard:
                reply_markup = self.keyboard_manager.create_keyboard(message_details.keyboard)
            
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–µ–¥–∏–∞ —á–µ—Ä–µ–∑ file_id
            if message_details.media_file_id and message_details.media_type:
                logger.info(f"üìÅ SENDING WITH MEDIA: {message_details.media_type} to {scheduled_msg.subscriber_id}")
                await self._send_media_message_file_id(
                    bot_instance,
                    scheduled_msg.subscriber_id,
                    formatted_text,
                    message_details.media_file_id,
                    message_details.media_type,
                    reply_markup
                )
            else:
                logger.info(f"üí¨ SENDING TEXT MESSAGE to {scheduled_msg.subscriber_id}")
                await self._send_text_message(
                    bot_instance,
                    scheduled_msg.subscriber_id,
                    formatted_text,
                    reply_markup
                )
                
            return True
            
        except TelegramForbiddenError:
            logger.warning(f"üö´ USER BLOCKED BOT: {scheduled_msg.subscriber_id}")
            return False
            
        except TelegramBadRequest as e:
            logger.error(f"‚ùå BAD REQUEST ERROR for user {scheduled_msg.subscriber_id}: {e}")
            return False
            
        except TelegramNetworkError as e:
            logger.error(f"‚ùå TELEGRAM NETWORK ERROR for user {scheduled_msg.subscriber_id}: {e}")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå UNEXPECTED ERROR SENDING MESSAGE {scheduled_msg.id}: {e}")
            return False
    
    async def _send_media_message_file_id(
        self, 
        bot: Bot, 
        user_id: int, 
        caption: str, 
        media_file_id: str, 
        media_type: str,
        reply_markup=None
    ):
        """Send media message using file_id"""
        try:
            logger.debug(f"üìÅ SENDING MEDIA VIA FILE_ID to {user_id}, "
                        f"type: {media_type}, file_id: {media_file_id[:20]}...")
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ç–∏–ø –º–µ–¥–∏–∞
            media_type_lower = media_type.lower()
            
            if media_type_lower in ['photo', 'image']:
                await bot.send_photo(
                    chat_id=user_id,
                    photo=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ PHOTO sent via file_id")
                
            elif media_type_lower in ['video']:
                await bot.send_video(
                    chat_id=user_id,
                    video=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ VIDEO sent via file_id")
                
            elif media_type_lower in ['document']:
                await bot.send_document(
                    chat_id=user_id,
                    document=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ DOCUMENT sent via file_id")
                
            elif media_type_lower in ['audio']:
                await bot.send_audio(
                    chat_id=user_id,
                    audio=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ AUDIO sent via file_id")
                
            elif media_type_lower in ['voice']:
                await bot.send_voice(
                    chat_id=user_id,
                    voice=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ VOICE sent via file_id")
                
            elif media_type_lower in ['video_note']:
                # –î–ª—è –≤–∏–¥–µ–æ–∫—Ä—É–∂–∫–æ–≤ caption –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
                await bot.send_video_note(
                    chat_id=user_id,
                    video_note=media_file_id,
                    reply_markup=reply_markup
                )
                # –ï—Å–ª–∏ –µ—Å—Ç—å caption, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
                if caption:
                    await bot.send_message(
                        chat_id=user_id,
                        text=caption,
                        parse_mode=ParseMode.HTML
                    )
                logger.debug("‚úÖ VIDEO_NOTE sent via file_id")
                
            else:
                # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø - –ø—Ä–æ–±—É–µ–º –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç
                logger.warning(f"ü§î UNKNOWN MEDIA TYPE: {media_type}, trying as document")
                await bot.send_document(
                    chat_id=user_id,
                    document=media_file_id,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.HTML
                )
                logger.debug("‚úÖ UNKNOWN TYPE sent as document")
                        
        except Exception as e:
            logger.error(f"‚ùå MEDIA FILE_ID FAILED for {user_id}: {e}")
            # Fallback –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await self._send_text_message(bot, user_id, caption, reply_markup)
    
    async def _send_text_message(
        self, 
        bot: Bot, 
        user_id: int, 
        text: str, 
        reply_markup: Optional[InlineKeyboardMarkup] = None
    ) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            await bot.send_message(
                chat_id=user_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.HTML,
                disable_web_page_preview=True
            )
            logger.debug(f"‚úÖ TEXT MESSAGE SENT to {user_id}")
            
        except Exception as e:
            logger.error(f"‚ùå TEXT MESSAGE FAILED for {user_id}: {e}")
            raise
    
    async def _mark_message_sent(self, scheduled_msg) -> None:
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –û—Ç–º–µ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ"""
        try:
            await db.update_scheduled_message_status(
                message_id=scheduled_msg.id,
                status='sent'
            )
            logger.debug(f"Message {scheduled_msg.id} marked as sent")
            
        except Exception as e:
            logger.error(f"‚ùå ERROR MARKING MESSAGE AS SENT {scheduled_msg.id}: {e}")
    
    async def _mark_message_failed(self, scheduled_msg, error: str) -> None:
        """‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –û—Ç–º–µ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ"""
        try:
            await db.update_scheduled_message_status(
                message_id=scheduled_msg.id,
                status='failed',
                error_message=error
            )
            logger.debug(f"Message {scheduled_msg.id} marked as failed: {error}")
            
        except Exception as e:
            logger.error(f"‚ùå ERROR MARKING MESSAGE AS FAILED {scheduled_msg.id}: {e}")
    
    async def schedule_message(
        self,
        bot_id: str,
        user_id: int,
        message_text: str,
        scheduled_time: datetime,
        media_file_id: Optional[str] = None,
        media_type: Optional[str] = None,
        buttons: Optional[List[Dict[str, str]]] = None
    ) -> bool:
        """–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (–¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)"""
        try:
            # –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤ –ë–î, –Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –≤ –±—É–¥—É—â–µ–º
            # –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞–∑–æ–≤—ã—Ö –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤–Ω–µ –≤–æ—Ä–æ–Ω–∫–∏
            
            logger.info(f"üìÖ MESSAGE SCHEDULE REQUEST", 
                       bot_id=bot_id,
                       user_id=user_id,
                       scheduled_time=scheduled_time,
                       has_media=bool(media_file_id))
            
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞–∑–æ–≤–æ–≥–æ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            # –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå ERROR SCHEDULING MESSAGE: {e}")
            return False
    
    def get_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
        return self.stats.copy()
    
    async def get_pending_count(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–∂–∏–¥–∞—é—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            pending_messages = await db.get_pending_scheduled_messages(limit=1000)
            return len(pending_messages)
        except Exception as e:
            logger.error(f"Error getting pending count: {e}")
            return 0
    
    async def get_status_summary(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–¥–∫—É —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
        return {
            'running': self.running,
            'scheduler_active': self.scheduler_task is not None and not self.scheduler_task.done(),
            'pending_messages': await self.get_pending_count(),
            'total_processed': self.stats['messages_processed'],
            'success_rate': (
                (self.stats['messages_sent_success'] / max(1, self.stats['messages_processed'])) * 100
                if self.stats['messages_processed'] > 0 else 0
            ),
            'last_run': self.stats['last_run'].isoformat() if self.stats['last_run'] else None
        }
